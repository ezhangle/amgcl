<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>amgcl: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gh.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">amgcl
   </div>
   <div id="projectbrief">Simple and generic AMG hierarchy builder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">amgcl Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/ddemidov/amgcl"></a></p>
<p>amgcl is a simple and generic algebraic <a href="http://en.wikipedia.org/wiki/Multigrid_method">multigrid</a> (AMG) hierarchy builder (and a work in progress). The constructed hierarchy may be used as a standalone solver or as a preconditioner with some iterative solver. Several <a href="http://ddemidov.github.io/amgcl/group__iterative.html">iterative solvers</a> are provided, and it is also possible to use generic solvers from other libraries, e.g. <a href="http://viennacl.sourceforge.net">ViennaCL</a>.</p>
<p>The setup phase is completely CPU-based. The constructed levels of AMG hierarchy may be stored and used through several <a href="http://ddemidov.github.io/amgcl/group__levels.html">backends</a>. This allows for transparent acceleration of the solution phase with help of OpenCL, CUDA, or OpenMP technologies. See <a href="https://github.com/ddemidov/amgcl/blob/master/examples/vexcl.cpp">examples/vexcl.cpp</a>, <a href="https://github.com/ddemidov/amgcl/blob/master/examples/viennacl.cpp">examples/viennacl.cpp</a> and <a href="https://github.com/ddemidov/amgcl/blob/master/examples/eigen.cpp">examples/eigen.cpp</a> for examples of using amgcl with <a href="https://github.com/ddemidov/vexcl">VexCL</a>, <a href="http://viennacl.sourceforge.net">ViennaCL</a>, and CPU backends.</p>
<p>Doxygen-generated documentation is available at <a href="http://ddemidov.github.io/amgcl">http://ddemidov.github.io/amgcl</a>.</p>
<h2>Overview</h2>
<p>You can use amgcl to solve large sparse system of linear equations in three simple steps: first, you have to select method components (this is a compile time decision); second, the AMG hierarchy has to be constructed from a system matrix; and third, the hierarchy is used to solve the equation system for a given right-hand side.</p>
<p>The list of interpolation schemes and available backends may be found in <a href="http://ddemidov.github.io/amgcl/group__interpolation.html">Interpolation</a> and <a href="http://ddemidov.github.io/amgcl/group__levels.html">Level Storage Backends</a> documentation modules. The aggregation and smoothed-aggregation interpolation schemes use less memory and are set up faster than classic interpolation, but their convergence rate is slower. They are well suited for GPU-accelerated backends, where the cost of the setup phase is much more important.</p>
<p>Here is the complete code example showing each step in action: </p>
<div class="fragment"><div class="line"><span class="comment">// First, we need to include relevant headers. Each header basically</span></div>
<div class="line"><span class="comment">// corresponds to an AMG component. Let&#39;s say we want to use conjugate gradient</span></div>
<div class="line"><span class="comment">// method preconditioned with smoothed aggregation AMG with VexCL backend:</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This is generic hierarchy builder.</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="amgcl_8hpp.html">amgcl/amgcl.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// It will use the following components:</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Interpolation scheme based on smoothed aggregation.</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interp__smoothed__aggr_8hpp.html">amgcl/interp_smoothed_aggr.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// Aggregates will be constructed with plain aggregation:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="aggr__plain_8hpp.html">amgcl/aggr_plain.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// VexCL will be used as a backend:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="level__vexcl_8hpp.html">amgcl/level_vexcl.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// The definition of conjugate gradient method:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cg_8hpp.html">amgcl/cg.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// VexCL context initialization (let&#39;s use all GPUs that support double precision):</span></div>
<div class="line">    vex::Context ctx( vex::Filter::Type(CL_DEVICE_TYPE_GPU) &amp;&amp; vex::Filter::DoublePrecision );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here, the system matrix and right-hand side are somehow constructed. The</span></div>
<div class="line">    <span class="comment">// system matrix data is stored in compressed row storage format in vectors</span></div>
<div class="line">    <span class="comment">// row, col, and val.</span></div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line">    std::vector&lt;int&gt;    row, col;</div>
<div class="line">    std::vector&lt;double&gt; val, rhs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We wrap the matrix data into amgcl-compatible type.</span></div>
<div class="line">    <span class="comment">// No data is copied here:</span></div>
<div class="line">    <span class="keyword">auto</span> A = <a class="code" href="namespaceamgcl_1_1sparse.html#a899b7e41ad18cfb005c48d9d8165b511">amgcl::sparse::map</a>(size, size, row.data(), col.data(), val.data());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The AMG builder type. Note the use of damped Jacobi relaxation (smoothing) on each level.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classamgcl_1_1solver.html">amgcl::solver</a>&lt;</div>
<div class="line">        <span class="keywordtype">double</span> <span class="comment">/* matrix value type */</span>, <span class="keywordtype">int</span> <span class="comment">/* matrix index type */</span>,</div>
<div class="line">        <a class="code" href="structamgcl_1_1interp_1_1smoothed__aggregation.html">amgcl::interp::smoothed_aggregation&lt;amgcl::aggr::plain&gt;</a>,</div>
<div class="line">        <a class="code" href="structamgcl_1_1level_1_1vexcl.html">amgcl::level::vexcl&lt;amgcl::relax::damped_jacobi&gt;</a></div>
<div class="line">    &gt; AMG;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The parameters. Most of the parameters have some reasonable defaults.</span></div>
<div class="line">    <span class="comment">// VexCL backend needs to know what context to use:</span></div>
<div class="line">    AMG::params prm;</div>
<div class="line">    prm.level.ctx = &amp;ctx;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here we construct the hierarchy:</span></div>
<div class="line">    AMG amg(A, prm);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Now let&#39;s solve the system of equations. We need to transfer matrix,</span></div>
<div class="line">    <span class="comment">// right-hand side, and initial approximation to GPUs. The matrix part may</span></div>
<div class="line">    <span class="comment">// be omitted though, since AMG already has it as part of the hierarchy:</span></div>
<div class="line">    std::vector&lt;double&gt; x(size, 0.0);</div>
<div class="line"></div>
<div class="line">    vex::vector&lt;double&gt; f(ctx.queue(), rhs);</div>
<div class="line">    vex::vector&lt;double&gt; u(ctx.queue(), x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Call AMG-preconditioned CG method:</span></div>
<div class="line">    <span class="keyword">auto</span> cnv = <a class="code" href="group__iterative.html#ga8b1eaa586d5a32da9f9a7e9a5e668216">amgcl::solve</a>(amg.top_matrix(), f, amg, u, <a class="code" href="structamgcl_1_1cg__tag.html">amgcl::cg_tag</a>());</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Iterations: &quot;</span> &lt;&lt; std::get&lt;0&gt;(cnv) &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Error:      &quot;</span> &lt;&lt; std::get&lt;1&gt;(cnv) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy the solution back to host:</span></div>
<div class="line">    vex::copy(u, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The following command line would compile the example: </p>
<div class="fragment"><div class="line">g++ -o example -std=c++0x -O3 -fopenmp example.cpp -I&lt;path/to/vexcl&gt; -I&lt;path/to/amgcl&gt; -lOpenCL</div>
</div><!-- fragment --><p> The C++11 support is enabled here (by <code>-std=c++0x</code> flag) because it is required by VexCL library. amgcl relies on Boost instead. Also note the use of <code>-fopenmp</code> switch. It enables an OpenMP-based parallelization of the setup stage.</p>
<h2>Performance</h2>
<p>Here is output of <code>utest</code> benchmark (see examples folder), solving 2D 2048x2048 Poisson problem generated with <code>./genproblem2d 2048</code>.</p>
<p>The first run is CPU-only (<code>--level=2</code>, see <code>./utest --help</code> for the options list). The CPU is Intel Core i7 920: </p>
<div class="fragment"><div class="line">$ ./utest --level 2</div>
<div class="line">Reading <span class="stringliteral">&quot;problem.dat&quot;</span>...</div>
<div class="line">Done</div>
<div class="line"></div>
<div class="line">Number of levels:    6</div>
<div class="line">Operator complexity: 1.34</div>
<div class="line">Grid complexity:     1.19</div>
<div class="line"></div>
<div class="line">level     unknowns       nonzeros</div>
<div class="line">---------------------------------</div>
<div class="line">    0      4194304       20938768 (74.75%)</div>
<div class="line">    1       698198        6278320 (22.41%)</div>
<div class="line">    2        77749         701425 ( 2.50%)</div>
<div class="line">    3         8814          82110 ( 0.29%)</div>
<div class="line">    4          988           9362 ( 0.03%)</div>
<div class="line">    5          115           1149 ( 0.00%)</div>
<div class="line"></div>
<div class="line">Iterations: 23</div>
<div class="line">Error:      4.12031e-09</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">[utest:              7.159 sec.] (100.00%)</div>
<div class="line">[ <span class="keyword">self</span>:              0.010 sec.] (  0.14%)</div>
<div class="line">[  Read problem:     0.131 sec.] (  1.82%)</div>
<div class="line">[  setup:            1.104 sec.] ( 15.42%)</div>
<div class="line">[  <a class="code" href="group__iterative.html#ga8b1eaa586d5a32da9f9a7e9a5e668216">solve</a>:            5.915 sec.] ( 82.62%)</div>
</div><!-- fragment --><p>The second run is VexCL-based, the GPU is NVIDIA Tesla C2075: </p>
<div class="fragment"><div class="line">$ ./utest --level=1</div>
<div class="line">Reading <span class="stringliteral">&quot;problem.dat&quot;</span>...</div>
<div class="line">Done</div>
<div class="line"></div>
<div class="line">1. Tesla C2075</div>
<div class="line"></div>
<div class="line">Number of levels:    6</div>
<div class="line">Operator complexity: 1.34</div>
<div class="line">Grid complexity:     1.19</div>
<div class="line"></div>
<div class="line">level     unknowns       nonzeros</div>
<div class="line">---------------------------------</div>
<div class="line">    0      4194304       20938768 (74.75%)</div>
<div class="line">    1       698198        6278320 (22.41%)</div>
<div class="line">    2        77749         701425 ( 2.50%)</div>
<div class="line">    3         8814          82110 ( 0.29%)</div>
<div class="line">    4          988           9362 ( 0.03%)</div>
<div class="line">    5          115           1149 ( 0.00%)</div>
<div class="line"></div>
<div class="line">Iterations: 23</div>
<div class="line">Error:      4.12031e-09</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">[utest:                       3.030 sec.] (100.00%)</div>
<div class="line">[ <span class="keyword">self</span>:                       0.028 sec.] (  0.93%)</div>
<div class="line">[  OpenCL initialization:     0.062 sec.] (  2.05%)</div>
<div class="line">[  Read problem:              0.133 sec.] (  4.37%)</div>
<div class="line">[  setup:                     2.082 sec.] ( 68.72%)</div>
<div class="line">[  <a class="code" href="group__iterative.html#ga8b1eaa586d5a32da9f9a7e9a5e668216">solve</a>:                     0.725 sec.] ( 23.93%)</div>
</div><!-- fragment --><p>Setup time has increased, because data structures have to be transfered to GPU memory. But due to the accelerated solution the total time is reduced. Further time savings may be expected if the preconditioner is reused for solution with different right-hand sides.</p>
<h2>Installation</h2>
<p>The library is header-only, so there is nothing to compile or link to. You just need to copy amgcl folder somewhere and tell your compiler to scan it for include files.</p>
<h2>Projects using amgcl</h2>
<ol type="1">
<li><a href="http://www.cimne.com/kratos">Kratos Multi-Physics</a> (an open source framework for the implementation of numerical methods for the solution of engineering problems) is using amgcl for solution of discretized PDEs.</li>
<li><a href="http://www.paralution.com/">PARALUTION</a> (a library allowing to employ various sparse iterative solvers and preconditioners on multi/many-core CPU and GPU devices) uses adopted amgcl code to build an algebraic multigrid hierarchy.</li>
</ol>
<h2>References</h2>
<ol type="1">
<li><em>U. Trottenberg, C. Oosterlee, A. Shuller,</em> Multigrid, Academic Press, London, 2001.</li>
<li><em>K. Stuben,</em> Algebraic multigrid (AMG): an introduction with applications, Journal of Computational and Applied Mathematics, 2001, Vol. 128, Pp. 281-309.</li>
<li><em>P. Vanek, J. Mandel, M. Brezina,</em> Algebraic multigrid by smoothed aggregation for second and fourth order elliptic problems, Computing 56, 1996, Pp. 179-196.</li>
<li><em>Y. Notay, P. Vassilevski,</em> Recursive Krylov-based multigrid cycles, Numer. Linear Algebra Appl. 2008; 15:473-487.</li>
<li><em>R. Barrett, M. Berry, T. F. Chan et al.</em> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods, 2nd Edition, SIAM, Philadelphia, PA, 1994.</li>
<li><em>O. Broeker, M. Grote,</em> Sparse approximate inverse smoothers for geometric and algebraic multigrid, Applied Numerical Mathematics, Volume 41, Issue 1, April 2002, Pages 61–80.</li>
<li><em>M. Sala, R. Tuminaro,</em> A new Petrov-Galerkin smoothed aggregation preconditioner for nonsymmetric linear systems. SIAM J. Sci. Comput. 2008, Vol. 31, No.1, pp. 143-166.</li>
</ol>
<hr/>
<p> <em>This work is a joint effort of <a href="http://www.jscc.ru/eng/index.shtml">Supercomputer Center of Russian Academy of Sciences</a> (Kazan branch) and <a href="http://www.kpfu.ru">Kazan Federal University</a>. It is partially supported by RFBR grants No 12-07-0007 and 12-01-00033.</em> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
