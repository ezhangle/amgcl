<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>AMGCL: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gh.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AMGCL
   </div>
   <div id="projectbrief">C++ header only library for constructing an AMG hierarchy</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AMGCL Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/ddemidov/amgcl"></a> <a href="https://coveralls.io/r/ddemidov/amgcl"></a></p>
<p>AMGCL is a C++ header only library for constructing an algebraic <a href="http://en.wikipedia.org/wiki/Multigrid_method">multigrid</a> (AMG) hierarchy. AMG is one the most effective methods for solution of large sparse unstructured systems of equations, arising, for example, from discretization of PDEs on unstructured grids [5,6]. The method can be used as a black-box solver for various computational problems, since it does not require any information about the underlying geometry. AMG is often used not as a standalone solver but as a preconditioner within an iterative solver (e.g. Conjugate Gradients, BiCGStab, or GMRES).</p>
<p>AMGCL builds the AMG hierarchy on a CPU and then transfers it to one of the provided backends. This allows for transparent acceleration of the solution phase with help of OpenCL, CUDA, or OpenMP technologies. Users may provide their own backends which enables tight integration between AMGCL and the user code.</p>
<p>The library source code is available under MIT license at <a href="https://github.com/ddemidov/amgcl">https://github.com/ddemidov/amgcl</a>. Doxygen-generated documentation is located at <a href="http://ddemidov.github.io/amgcl">http://ddemidov.github.io/amgcl</a>.</p>
<h3>Table of contents</h3>
<ul>
<li><a href="#getting-started">Getting started</a><ul>
<li><a href="#backends">Backends</a></li>
<li><a href="#coarsening">Coarsening strategies</a></li>
<li><a href="#relaxation">Relaxation schemes</a></li>
<li><a href="#solvers">Solvers</a></li>
</ul>
</li>
<li><a href="#extending">Extending AMGCL</a><ul>
<li><a href="#adding-backends">Adding backends</a></li>
<li><a href="#adding-coarseners">Adding coarseners</a></li>
<li><a href="#adding-smoothers">Adding smoothers</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#projects">Projects using AMGCL</a></li>
</ul>
<h2><a class="anchor" id="getting-started"></a>Getting started</h2>
<p>The main class of the library is <code><a class="el" href="classamgcl_1_1amg.html" title="Algebraic multigrid method. ">amgcl::amg</a>&lt;Backend, Coarsening, Relaxation&gt;</code> which is defined in <a href="amgcl/amgcl.hpp">amgcl/amgcl.hpp</a>. It has three template parameters that allow the user to select the exact components of the method:</p>
<ol type="1">
<li><b>Backend</b> to transfer the constructed hierarchy to,</li>
<li><b>Coarsening</b> strategy for hierarchy construction, and</li>
<li><b>Relaxation</b> scheme (smoother to use during the solution phase).</li>
</ol>
<p>See below for the list of available choices for each of the template parameters. Instance of the class builds the AMG hierarchy for the given system matrix and is intended to be used as a preconditioner. Here is the complete example that solves a linear system of equations with BiCGstab method on a multicore CPU, uses classic Ruge-Stuben algorithm for coarsening and damped Jacobi smoother for relaxation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of the main class</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="amgcl_8hpp.html">amgcl/amgcl.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Builtin backend: works on CPU, uses OpenMP for parallelization</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="builtin_8hpp.html">amgcl/backend/builtin.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Allows to specify system matrix as a tuple of sizes and ranges (as in Boost.Range).</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="crs__tuple_8hpp.html">amgcl/backend/crs_tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Classic Ruge-Stuben coarsening algorithm</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ruge__stuben_8hpp.html">amgcl/coarsening/ruge_stuben.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Damped Jacobi relaxation</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="damped__jacobi_8hpp.html">amgcl/relaxation/damped_jacobi.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// BiCGStab iterative solver</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bicgstab_8hpp.html">amgcl/solver/bicgstab.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Sparse matrix in CRS format (the assembling is omitted for clarity):</span></div>
<div class="line">    <span class="keywordtype">int</span> n;                   <span class="comment">// Matrix size</span></div>
<div class="line">    std::vector&lt;double&gt; val; <span class="comment">// Values of nonzero entries.</span></div>
<div class="line">    std::vector&lt;int&gt;    col; <span class="comment">// Column numbers of nonzero entries.</span></div>
<div class="line">    std::vector&lt;int&gt;    ptr; <span class="comment">// Points to the start of each row in the above arrays.</span></div>
<div class="line">    std::vector&lt;double&gt; rhs; <span class="comment">// Right-hand side of the system of equations.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Define the AMG type:</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classamgcl_1_1amg.html">amgcl::amg</a>&lt;</div>
<div class="line">        <a class="code" href="structamgcl_1_1backend_1_1builtin.html">amgcl::backend::builtin&lt;double&gt;</a>,</div>
<div class="line">        <a class="code" href="structamgcl_1_1coarsening_1_1ruge__stuben.html">amgcl::coarsening::ruge_stuben</a>,</div>
<div class="line">        <a class="code" href="structamgcl_1_1relaxation_1_1damped__jacobi.html">amgcl::relaxation::damped_jacobi</a></div>
<div class="line">        &gt; AMG;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Construct the AMG hierarchy.</span></div>
<div class="line">    <span class="comment">// Note that this step only depends on the matrix. Hence, the constructed</span></div>
<div class="line">    <span class="comment">// instance may be reused for several right-hand sides.</span></div>
<div class="line">    <span class="comment">// The matrix is specified as a tuple of sizes and ranges.</span></div>
<div class="line">    AMG amg( boost::tie(n, val, col, ptr) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output some information about the constructed hierarchy:</span></div>
<div class="line">    std::cout &lt;&lt; amg &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use BiCGStab as an iterative solver:</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classamgcl_1_1solver_1_1bicgstab.html">amgcl::solver::bicgstab</a>&lt;</div>
<div class="line">        amgcl::backend::builtin&lt;double&gt;</div>
<div class="line">        &gt; Solver;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Construct the iterative solver. It needs size of the system to</span></div>
<div class="line">    <span class="comment">// preallocate the required temporary structures:</span></div>
<div class="line">    Solver solve(n);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The solution vector. Use zero as initial approximation.</span></div>
<div class="line">    std::vector&lt;double&gt; x(n, 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Solve the system. Returns number of iterations made and the achieved residual.</span></div>
<div class="line">    <span class="keywordtype">int</span>    iters;</div>
<div class="line">    <span class="keywordtype">double</span> resid;</div>
<div class="line">    boost::tie(iters, resid) = solve(amg, rhs, x);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Iterations: &quot;</span> &lt;&lt; iters &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Error:      &quot;</span> &lt;&lt; resid &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There is a convenience class <code><a class="el" href="classamgcl_1_1make__solver.html" title="Convenience class that creates a pair of AMG preconditioner and iterative solver. ...">amgcl::make_solver</a>&lt;Backend, Coarsening, Relaxation, Solver&gt;</code> which wraps both an AMG preconditioner and an iterative solver. By using the class the above example could be made a bit shorter:</p>
<div class="fragment"><div class="line"><span class="comment">// Construct the AMG hierarchy and create the iterative solver.</span></div>
<div class="line"><a class="code" href="classamgcl_1_1make__solver.html">amgcl::make_solver</a>&lt;</div>
<div class="line">    amgcl::backend::builtin&lt;double&gt;,</div>
<div class="line">    amgcl::coarsening::ruge_stuben,</div>
<div class="line">    <a class="code" href="structamgcl_1_1relaxation_1_1damped__jacobi.html">amgcl::relaxation::damped_jacobi</a>,</div>
<div class="line">    <a class="code" href="classamgcl_1_1solver_1_1bicgstab.html">amgcl::solver::bicgstab</a></div>
<div class="line">    &gt; solve( boost::tie(n, val, col, ptr) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Solve the linear system.</span></div>
<div class="line">boost::tie(iters, resid) = solve(rhs, x);</div>
</div><!-- fragment --><h3><a class="anchor" id="backends"></a>Backends</h3>
<p>A backend in AMGCL is a class that defines matrix and vector types together with several operations on them, such as creation, matrix-vector products, vector sums, inner products etc. See <a href="#adding-backends">Adding backends</a> for more detailed description of a backend implementation. The AMG hierarchy is moved to the specified backend upon construction. The solution phase then uses types and operations defined in the backend. This enables transparent acceleration of the solution phase with OpenMP, OpenCL, CUDA, or any other technologies.</p>
<p>Here is the list of backends currently implemented in the library:</p>
<ul>
<li><code><a class="el" href="structamgcl_1_1backend_1_1builtin.html" title="Builtin backend. ">amgcl::backend::builtin</a>&lt;value_type&gt;</code> (defined in <a href="amgcl/backend/builtin.hpp">amgcl/backend/builtin.hpp</a>). The <code>builtin</code> backend does not have any external dependencies (except for the <a href="http://www.boost.org">Boost</a> libraries), and uses OpenMP for parallelization. It uses CRS format for storing matrices. Vectors are instances of <code>std::vector&lt;value_type&gt;</code>. There is no usual overhead for moving the constructed hierarchy to the builtin backend, since the backend is always used internally during construction.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1block__crs.html" title="block_crs backend definition. ">amgcl::backend::block_crs</a>&lt;value_type&gt;</code> (<a href="amgcl/backend/block_crs.hpp">amgcl/backend/block_crs.hpp</a>). The <code>block_crs</code> backend is similar to the <code>builtin</code> backend. The only difference is that it uses Block CRS format for storing matrices. The format is well suited for matrices that have block structure. This is usualy the case when a system of coupled PDEs is discretized.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1eigen.html" title="Eigen backend. ">amgcl::backend::eigen</a>&lt;value_type&gt;</code> (<a href="amgcl/backend/eigen.hpp">amgcl/backend/eigen.hpp</a>). The <code>eigen</code> backend uses types and operations from <a href="http://eigen.tuxfamily.org">Eigen</a> library. Eigen is a C++ template library for linear algebra. It works on a CPU and as of this writing is single threaded.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1blaze.html" title="Blaze backend. ">amgcl::backend::blaze</a>&lt;value_type&gt;</code> (<a href="amgcl/backend/blaze.hpp">amgcl/backend/blaze.hpp</a>). The <code>blaze</code> backend uses types and operations from <a href="https://code.google.com/p/blaze-lib">Blaze</a> library. Blaze is an open-source, high-performance C++ math library for dense and sparse arithmetic.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1vexcl.html" title="VexCL backend. ">amgcl::backend::vexcl</a>&lt;value_type&gt;</code> (<a href="amgcl/backend/vexcl.hpp">amgcl/backend/vexcl.hpp</a>). The <code>vexcl</code> backend uses <a href="http://github.com/ddemidov/vexcl">VexCL</a> library for accelerating the solution phase. VexCL is a C++ vector expression template library for OpenCL/CUDA. VexCL is able to utilize several compute devices at once.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1viennacl.html" title="ViennaCL backend. ">amgcl::backend::viennacl</a>&lt;matrix_type&gt;</code> (<a href="amgcl/backend/viennacl.hpp">amgcl/backend/viennacl.hpp</a>). The <code>viennacl</code> backend is built on top of <a href="http://viennacl.sourceforge.net">ViennaCL</a> library which is a free open-source linear algebra library for computations on many-core architectures (GPUs, MIC) and multi-core CPUs.</li>
<li><code><a class="el" href="structamgcl_1_1backend_1_1cuda.html" title="CUDA backend. ">amgcl::backend::cuda</a>&lt;value_type&gt;</code> (<a href="amgcl/backend/cuda.hpp">amgcl/backend/cuda.hpp</a>). Uses CUDA libraries CUSPARSE and Thrust for matrix and vector operations.</li>
<li><code>amgcl::backend::crs_tuple&lt;value_type&gt;</code> (<a href="amgcl/backend/crs_tuple.hpp">amgcl/backend/crs_tuple.hpp</a>). The <code>crs_tuple</code> backend is in fact not a usable backend. It only exists to facilitate construction of <code><a class="el" href="classamgcl_1_1amg.html" title="Algebraic multigrid method. ">amgcl::amg</a>&lt;&gt;</code> instances from user matrices strored in CRS format. A <code>boost::tuple</code> of matrix dimensions and ranges of nonzero values, columns, and row pointers may be used. The example above illustrates how the backend may be used with <code>std::vector&lt;&gt;</code>s. Below is an example that uses raw pointers:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n;       <span class="comment">// Matrix size.</span></div>
<div class="line"><span class="keywordtype">double</span> *val; <span class="comment">// Values.</span></div>
<div class="line"><span class="keywordtype">int</span>    *col; <span class="comment">// Column numbers.</span></div>
<div class="line"><span class="keywordtype">int</span>    *ptr  <span class="comment">// Row pointers into the above arrays.</span></div>
<div class="line"></div>
<div class="line">AMG amg( boost::make_tuple(</div>
<div class="line">            n,</div>
<div class="line">            boost::make_iterator_range(val, val + ptr[n]),</div>
<div class="line">            boost::make_iterator_range(col, col + ptr[n]),</div>
<div class="line">            boost::make_iterator_range(ptr, ptr + n + 1)</div>
<div class="line">            )</div>
<div class="line">        );</div>
</div><!-- fragment --><h3><a class="anchor" id="coarsening"></a>Coarsening strategies</h3>
<p>A coarsener in AMGCL is a class that takes a system matrix and returns three operators:</p>
<ol type="1">
<li>Restriction operator <code>R</code> that downsamples the residual error to a coarser level in AMG hierarchy,</li>
<li>Prolongation operator <code>P</code> that interpolates a correction computed on a coarser grid into a finer grid,</li>
<li>System matrix <code>A'</code> at a coarser level that is usually computed as a Galerkin operator `A' = R A P`.</li>
</ol>
<p>The AMG hierarchy is constructed by recursive invocation of the selected coarsener. Below is the list of coarsening strategies implemented in the library.</p>
<ul>
<li>Classic Ruge-Stuben coarsening implemented as <code><a class="el" href="structamgcl_1_1coarsening_1_1ruge__stuben.html" title="Classic Ruge-Stuben coarsening with direct interpolation. ">amgcl::coarsening::ruge_stuben</a></code> class (defined in <a href="amgcl/coarsening/ruge_stuben.hpp">amgcl/coarsening/ruge_stuben.hpp</a>). Ruge-Stuben coarsening usually results in a more efficient multigrid cycles at the price of increased construction time and higher memory requirements.</li>
<li>Aggregation based coarsening strategies. Aggregation based coarseners are implemented as class templates with a single template parameter. The parameter controls how fine-level variables are subdivided into aggregates. Possible choices are <code><a class="el" href="structamgcl_1_1coarsening_1_1plain__aggregates.html" title="Plain aggregation. ">amgcl::coarsening::plain_aggregates</a></code> (<a href="amgcl/coarsening/plain_aggregates.hpp">amgcl/coarsening/plain_aggregates.hpp</a>) and <code><a class="el" href="classamgcl_1_1coarsening_1_1pointwise__aggregates.html" title="Pointwise aggregation. ">amgcl::coarsening::pointwise_aggregates</a></code> (<a href="amgcl/coarsening/pointwise_aggregates.hpp">amgcl/coarsening/pointwise_aggregates.hpp</a>). The latter may be used when a system of coupled PDEs is solved. In this case the aggregation acts on grid points instead of individual variables.<ul>
<li>Non-smoothed aggregation: <code><a class="el" href="structamgcl_1_1coarsening_1_1aggregation.html" title="Non-smoothed aggregation. ">amgcl::coarsening::aggregation</a>&lt;Aggregates&gt;</code> (<a href="amgcl/coarsening/aggregation.hpp">amgcl/coarsening/aggregation.hpp</a>).</li>
<li>Smoothed aggregation: <code><a class="el" href="structamgcl_1_1coarsening_1_1smoothed__aggregation.html" title="Smoothed aggregation coarsening. ">amgcl::coarsening::smoothed_aggregation</a>&lt;Aggregates&gt;</code> (<a href="amgcl/coarsening/smoothed_aggregation.hpp">amgcl/coarsening/smoothed_aggregation.hpp</a>).</li>
<li>Smoothed aggregation with energy minimization (see [4]): <code><a class="el" href="structamgcl_1_1coarsening_1_1smoothed__aggr__emin.html" title="Smoothed aggregation with energy minimization. ">amgcl::coarsening::smoothed_aggr_emin</a>&lt;Aggregates&gt;</code> (<a href="amgcl/coarsening/smoothed_aggr_emin.hpp">amgcl/coarsening/smoothed_aggr_emin.hpp</a>).</li>
</ul>
</li>
</ul>
<p>In many cases the best choice is the smoothed aggregation coarsening. It results in quick construction with low memory consumption and is well suited for backends with GPGPU acceleration.</p>
<h3><a class="anchor" id="relaxation"></a>Relaxation schemes</h3>
<ul>
<li>Gauss-Seidel relaxation: <code><a class="el" href="structamgcl_1_1relaxation_1_1gauss__seidel.html" title="Gauss-Seidel relaxation. ">amgcl::relaxation::gauss_seidel</a></code> (<a href="amgcl/relaxation/gauss_seidel.hpp">amgcl/relaxation/gauss_seidel.hpp</a>).</li>
<li>ILU0 smoother: <code><a class="el" href="structamgcl_1_1relaxation_1_1ilu0.html" title="ILU(0) smoother. ">amgcl::relaxation::ilu0</a></code> (<a href="amgcl/relaxation/ilu0.hpp">amgcl/relaxation/ilu0.hpp</a>).</li>
<li>Damped Jacobi relaxation: <code><a class="el" href="structamgcl_1_1relaxation_1_1damped__jacobi.html" title="Damped Jacobi relaxation. ">amgcl::relaxation::damped_jacobi</a></code> (<a href="amgcl/relaxation/damped_jacobi.hpp">amgcl/relaxation/damped_jacobi.hpp</a>).</li>
<li>Sparse approximate inverse smoother: <code><a class="el" href="structamgcl_1_1relaxation_1_1spai0.html" title="Sparse approximate interface smoother. ">amgcl::relaxation::spai0</a></code> (<a href="amgcl/relaxation/spai0.hpp">amgcl/relaxation/spai0.hpp</a>).</li>
<li>Chebyshev polynomial smoother: <code><a class="el" href="classamgcl_1_1relaxation_1_1chebyshev.html" title="Chebyshev polynomial smoother. ">amgcl::relaxation::chebyshev</a></code> (<a href="amgcl/relaxation/chebyshev.hpp">amgcl/relaxation/chebyshev.hpp</a>).</li>
</ul>
<p><em>Note that Gauss-Seidel and ILU0 smoothers are serial in nature and thus are only implemented for CPU-based backends that offer iteration over matrix rows (currently <code>builtin</code> and <code>eigen</code> backends).</em></p>
<h3><a class="anchor" id="solvers"></a>Solvers</h3>
<p>AMGCL provides several iterative solvers, but it should be easy to use it as a preconditioner with a user-provided solver.</p>
<ul>
<li>Conjugate Gradients solver: <code><a class="el" href="classamgcl_1_1solver_1_1cg.html" title="Conjugate Gradients iterative solver. ">amgcl::solver::cg</a>&lt;Backend&gt;</code> (<a href="amgcl/solver/cg.hpp">amgcl/solver/cg.hpp</a>).</li>
<li>BiCGStab: <code><a class="el" href="classamgcl_1_1solver_1_1bicgstab.html" title="BiCGStab iterative solver. ">amgcl::solver::bicgstab</a>&lt;Backend&gt;</code> (<a href="amgcl/solver/bicgstab.hpp">amgcl/solver/bicgstab.hpp</a>).</li>
<li>GMRES: <code><a class="el" href="classamgcl_1_1solver_1_1gmres.html" title="GMRES iterative solver. ">amgcl::solver::gmres</a>&lt;Backend&gt;</code> (<a href="amgcl/solver/gmres.hpp">amgcl/solver/gmres.hpp</a>).</li>
</ul>
<p>Each solver in AMGCL is a class template. Its single template parameter specifies the backend to use. This allows to preallocate necessary resources at class construction. Obviously, the solver backend has to coincide with the AMG backend.</p>
<p>Solvers provide two versions of function call operator. The simpler version takes a constructed AMG instance, a right-hand side vector, and a solution vector. This version solves the same system of equations that was used for the construction of AMG hierarchy.</p>
<p>The other version also takes a system matrix as first parameter. This version may be used for the solution of non-stationary problems with slowly changing coefficients. There is a strong chance that AMG built for one time step will act as a reasonably good preconditioner for several subsequent time steps [3].</p>
<p>Both versions return a tuple of number of iterations made and a residual error achieved.</p>
<h2><a class="anchor" id="extending"></a>Extending AMGCL</h2>
<h3><a class="anchor" id="adding-backends"></a>Adding backends</h3>
<p>A backend is a class that defines a matrix and a vector types, and provides static member functions for cloning and creating matrices and vectors. Users also have to define several operations acting on backend matrices and vectors:</p>
<ul>
<li>Getting matrix dimensions and number of nonzero values,</li>
<li>Implementation of matrix vector product,</li>
<li>Implementation of residual error computation,</li>
<li>Clear vector elments, copy vector elements from another vector,</li>
<li>Implementation of linear combinations for vectors.</li>
</ul>
<p>See <a href="amgcl/backend/vexcl.hpp">amgcl/backend/vexcl.hpp</a> for a complete example of backend implementation.</p>
<h3><a class="anchor" id="adding-coarseners"></a>Adding coarseners</h3>
<p>A coarsener in AMGCL should have the following interface:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_coarsener {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>params {</div>
<div class="line">        <span class="comment">// Coarsener parameters, if any.</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructs transfer operators.</span></div>
<div class="line">    <span class="comment">// Takes system matrix in builtin format and parameters.</span></div>
<div class="line">    <span class="comment">// Operators are returned in a tuple of shared pointers.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val, <span class="keyword">typename</span> Col, <span class="keyword">typename</span> Ptr&gt;</div>
<div class="line">    <span class="keyword">static</span> boost::tuple&lt;</div>
<div class="line">        boost::shared_ptr&lt; backend::crs&lt;Val, Col, Ptr&gt; &gt;,</div>
<div class="line">        boost::shared_ptr&lt; backend::crs&lt;Val, Col, Ptr&gt; &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    transfer_operators(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="structamgcl_1_1backend_1_1crs.html">amgcl::backend::crs&lt;Val, Col, Ptr&gt;</a> &amp;A,</div>
<div class="line">        <span class="keyword">const</span> params &amp;prm</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Returns system matrix for the coarser level.</span></div>
<div class="line">    <span class="comment">// Takes system matrix and transfer operators for the current level.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val, <span class="keyword">typename</span> Col, <span class="keyword">typename</span> Ptr&gt;</div>
<div class="line">    <span class="keyword">static</span> boost::shared_ptr&lt; backend::crs&lt;Val, Col, Ptr&gt; &gt;</div>
<div class="line">    coarse_operator(</div>
<div class="line">            <span class="keyword">const</span> backend::crs&lt;Val, Col, Ptr&gt; &amp;A,</div>
<div class="line">            <span class="keyword">const</span> backend::crs&lt;Val, Col, Ptr&gt; &amp;P,</div>
<div class="line">            <span class="keyword">const</span> backend::crs&lt;Val, Col, Ptr&gt; &amp;R,</div>
<div class="line">            <span class="keyword">const</span> params &amp;prm</div>
<div class="line">            );</div>
<div class="line">};</div>
</div><!-- fragment --><p>Have a look at <a href="amgcl/coarsening/aggregation.hpp">amgcl/coarsening/aggregation.hpp</a> for an example.</p>
<h3><a class="anchor" id="adding-smoothers"></a>Adding smoothers</h3>
<p>Here is the interface of an AMGCL smoother:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Backend&gt;</div>
<div class="line"><span class="keyword">class </span>my_smoother {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>params {</div>
<div class="line">        <span class="comment">// Smoother parameters, if any.</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    <span class="comment">// Takes system matrix in builtin format, smoother parameters, and backend</span></div>
<div class="line">    <span class="comment">// parameters.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val, <span class="keyword">typename</span> Col, <span class="keyword">typename</span> Ptr&gt;</div>
<div class="line">    my_smoother(</div>
<div class="line">        <span class="keyword">const</span> backend::crs&lt;Val, Col, Ptr&gt; &amp;A,</div>
<div class="line">        <span class="keyword">const</span> params &amp;prm,</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> Backend::params &amp;backend_prm</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-relaxation.</span></div>
<div class="line">    <span class="comment">// Takes system matrix in backend format, right-hand side and solution</span></div>
<div class="line">    <span class="comment">// vectors, and a vector for temporary storage.</span></div>
<div class="line">    <span class="keywordtype">void</span> apply_pre(</div>
<div class="line">            <span class="keyword">typename</span> Backend::matrix <span class="keyword">const</span> &amp;A,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector <span class="keyword">const</span> &amp;rhs,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector <span class="keyword">const</span> &amp;x,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector       &amp;tmp,</div>
<div class="line">            <span class="keyword">const</span> params &amp;prm</div>
<div class="line">            ) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Post-relaxation.</span></div>
<div class="line">    <span class="comment">// In case the smoother is symmetric, may just call apply_pre.</span></div>
<div class="line">    <span class="keywordtype">void</span> apply_post(</div>
<div class="line">            <span class="keyword">typename</span> Backend::matrix <span class="keyword">const</span> &amp;A,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector <span class="keyword">const</span> &amp;rhs,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector <span class="keyword">const</span> &amp;x,</div>
<div class="line">            <span class="keyword">typename</span> Backend::vector       &amp;tmp,</div>
<div class="line">            <span class="keyword">const</span> params &amp;prm</div>
<div class="line">            ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Have a look at <a href="amgcl/relaxation/damped_jacobi.hpp">amgcl/relaxation/damped_jacobi.hpp</a> for an example.</p>
<h2><a class="anchor" id="references"></a>References</h2>
<ol type="1">
<li>R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine, and H. Van der Vorst. Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods, 2nd Edition. SIAM, Philadelphia, PA, 1994.</li>
<li>O. Bröker and M. J. Grote. Sparse approximate inverse smoothers for geometric and algebraic multigrid. Applied numerical mathematics, 41(1):61–80, 2002.</li>
<li>D. E. Demidov and D. V. Shevchenko. Modification of algebraic multigrid for effective gpgpu-based solution of nonstationary hydrodynamics problems. Journal of Computational Science, 3(6):460–462, 2012.</li>
<li>M. Sala and R. S. Tuminaro. A new petrov-galerkin smoothed aggregation preconditioner for nonsymmetric linear systems. SIAM Journal on Scientific Computing, 31(1):143–166, 2008.</li>
<li>K. Stuben. Algebraic multigrid (AMG): an introduction with applications. GMD Report 70, GMD, Sankt Augustin, Germany, 1999.</li>
<li>U. Trottenberg, C. Oosterlee, and A. Schüller. Multigrid. Academic Press, London, 2001. 631 p.</li>
<li>P. Vanek, J. Mandel, and M. Brezina. Algebraic multigrid by smoothed aggregation for second and fourth order elliptic problems. Computing, 56(3):179–196, 1996.</li>
</ol>
<h2><a class="anchor" id="references"></a>Projects using AMGCL</h2>
<ul>
<li><a href="http://www.cimne.com/kratos">Kratos Multi-Physics</a> (an open source framework for the implementation of numerical methods for the solution of engineering problems) is using AMGCL for solution of discretized PDEs.</li>
<li><a href="http://www.paralution.com">PARALUTION</a> (a library allowing to employ various sparse iterative solvers and preconditioners on multi/many-core CPU and GPU devices) uses adopted AMGCL code to build an algebraic multigrid hierarchy. <hr/>
 <em>This work is a joint effort of <a href="http://www.jscc.ru/eng/index.shtml">Supercomputer Center of Russian Academy of Sciences</a> (Kazan branch) and <a href="http://www.kpfu.ru">Kazan Federal University</a>. It is partially supported by RFBR grants No 12-07-0007 and 12-01-00033.</em> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
