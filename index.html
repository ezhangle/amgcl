<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>amgcl: amgcl Generic algebraic multigrid framework.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">amgcl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">amgcl Generic algebraic multigrid framework. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>amgcl is a simple and generic algebraic <a href="http://en.wikipedia.org/wiki/Multigrid_method">multigrid</a> (AMG) hierarchy builder (and a work in progress). The constructed hierarchy may be used as a standalone solver or as a preconditioner with some iterative solver. Several <a class="el" href="group__iterative.html">iterative solvers</a> are provided, and it is also possible to use generic solvers from other libraries, e.g. <a href="http://viennacl.sourceforge.net">ViennaCL</a>.</p>
<p>The setup phase is completely CPU-based. The constructed levels of AMG hierarchy may be stored and used through several <a class="el" href="group__levels.html">backends</a>. This allows for transparent acceleration of the solution phase with help of OpenCL, CUDA, or OpenMP technologies. See <a href="https://github.com/ddemidov/amgcl/blob/master/examples/vexcl.cpp">examples/vexcl.cpp</a>, <a href="https://github.com/ddemidov/amgcl/blob/master/examples/viennacl.cpp">examples/viennacl.cpp</a> and <a href="https://github.com/ddemidov/amgcl/blob/master/examples/eigen.cpp">examples/eigen.cpp</a> for examples of using amgcl with <a href="https://github.com/ddemidov/vexcl">VexCL</a>, <a href="http://viennacl.sourceforge.net">ViennaCL</a>, or CPU backends.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>You can use amgcl to solve large sparse system of linear equations in three simple steps: first, you have to select method components (this is a compile time decision); second, the AMG hierarchy has to be constructed from a system matrix; and third, the hierarchy is used to solve the equation system for a given right-hand side.</p>
<p>The list of interpolation schemes and available backends may be found in <a class="el" href="group__interpolation.html">Interpolation</a> and <a class="el" href="group__levels.html">Level Storage Backends</a> modules. The aggregation and smoothed-aggregation interpolation schemes use less memory and are set up faster than classic interpolation, but their convergence rate is slower. They are well suited for GPU-accelerated backends, where the cost of the setup phase is much more important.</p>
<div class="fragment"><div class="line"><span class="comment">// First, we need to include relevant headers. Each header basically</span></div>
<div class="line"><span class="comment">// corresponds to an AMG component. Let&#39;s say we want to use conjugate gradient</span></div>
<div class="line"><span class="comment">// method preconditioned with smoothed aggregation AMG with VexCL backend:</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This is generic hierarchy builder.</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="amgcl_8hpp.html" title="Generic algebraic multigrid framework.">amgcl/amgcl.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// It will use the following components:</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Interpolation scheme based on smoothed aggregation.</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interp__smoothed__aggr_8hpp.html" title="Interpolation scheme based on smoothed aggregation.">amgcl/interp_smoothed_aggr.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// Aggregates will be constructed with plain aggregation:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="aggr__plain_8hpp.html" title="Plain aggregation.">amgcl/aggr_plain.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// VexCL will be used as a backend:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="level__vexcl_8hpp.html" title="Level of an AMG hierarchy for use with VexCL vectors.">amgcl/level_vexcl.hpp</a>&gt;</span></div>
<div class="line"><span class="comment">// The definition of conjugate gradient method:</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cg_8hpp.html" title="Conjugate Gradient method.">amgcl/cg.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// VexCL context initialization (let&#39;s use all GPUs that support double precision):</span></div>
<div class="line">    vex::Context ctx( vex::Filter::Type(CL_DEVICE_TYPE_GPU) &amp;&amp; vex::Filter::DoublePrecision );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here, the system matrix and right-hand side are somehow constructed. The</span></div>
<div class="line">    <span class="comment">// system matrix data is stored in compressed row storage format in vectors</span></div>
<div class="line">    <span class="comment">// row, col, and val.</span></div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line">    std::vector&lt;int&gt;    row, col;</div>
<div class="line">    std::vector&lt;double&gt; val, rhs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We wrap the matrix data into amgcl-compatible type.</span></div>
<div class="line">    <span class="comment">// No data is copied here:</span></div>
<div class="line">    <span class="keyword">auto</span> A = <a class="code" href="namespaceamgcl_1_1sparse.html#a899b7e41ad18cfb005c48d9d8165b511" title="Maps Eigen sparse matrix to format supported by amgcl.">amgcl::sparse::map</a>(size, size, row.data(), col.data(), val.data());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The AMG builder type. Note the use of damped Jacobi relaxation (smoothing) on each level.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classamgcl_1_1solver.html" title="Algebraic multigrid method.">amgcl::solver</a>&lt;</div>
<div class="line">        double, int,</div>
<div class="line">        <a class="code" href="structamgcl_1_1interp_1_1smoothed__aggregation.html" title="Interpolation scheme based on smoothed aggregation.">amgcl::interp::smoothed_aggregation&lt;amgcl::aggr::plain&gt;</a>,</div>
<div class="line">        <a class="code" href="structamgcl_1_1level_1_1vexcl.html" title="VexCL-based AMG hierarchy.">amgcl::level::vexcl&lt;amgcl::relax::damped_jacobi&gt;</a></div>
<div class="line">    &gt; AMG;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The parameters. Most of the parameters have some reasonable defaults.</span></div>
<div class="line">    <span class="comment">// VexCL backend needs to know what context to use:</span></div>
<div class="line">    AMG::params prm;</div>
<div class="line">    prm.level.ctx = &amp;ctx;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here we construct the hierarchy:</span></div>
<div class="line">    AMG amg(A, prm);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Now let&#39;s solve the system of equations. We need to transfer matrix,</span></div>
<div class="line">    <span class="comment">// right-hand side, and initial approximation to GPUs. The matrix part may</span></div>
<div class="line">    <span class="comment">// be omitted though, since AMG already has it as part of the hierarchy:</span></div>
<div class="line">    std::vector&lt;double&gt; x(size, 0.0);</div>
<div class="line"></div>
<div class="line">    vex::vector&lt;double&gt; f(ctx.queue(), rhs);</div>
<div class="line">    vex::vector&lt;double&gt; u(ctx.queue(), x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Call AMG-preconditioned CG method:</span></div>
<div class="line">    <span class="keyword">auto</span> cnv = <a class="code" href="group__iterative.html#ga09895d1c0824481a5c96533827bdae15" title="Stabilized BiConjugate Gradient method.">amgcl::solve</a>(amg.top_matrix(), f, amg, u, <a class="code" href="structamgcl_1_1cg__tag.html" title="Control parameters for Conjugate Gradient method.">amgcl::cg_tag</a>());</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Iterations: &quot;</span> &lt;&lt; std::get&lt;0&gt;(cnv) &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Error:      &quot;</span> &lt;&lt; std::get&lt;1&gt;(cnv) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy the solution back to host:</span></div>
<div class="line">    vex::copy(u, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following command line would compile the example: </p>
<pre class="fragment">g++ -o example -std=c++0x -O3 -fopenmp example.cpp -I&lt;path/to/vexcl&gt; -I&lt;path/to/amgcl&gt; -lOpenCL -lboost_chrono
</pre><p>The C++11 support is enabled here (by -std=c++0x flag) because it is required by VexCL library. amgcl relies on Boost instead. Also note the use of <code>-fopenmp</code> switch. It enables an OpenMP-based parallelization of the setup stage.</p>
<h1><a class="anchor" id="install"></a>
Installation</h1>
<p>The library is header-only, so there is nothing to compile or link to. You just need to copy amgcl folder somewhere and tell your compiler to scan it for include files.</p>
<h1><a class="anchor" id="references"></a>
References</h1>
<ol type="1">
<li><a class="anchor" id="Trottenberg_2001"></a><em>U. Trottenberg, C. Oosterlee, A. Shuller,</em> Multigrid, Academic Press, London, 2001.</li>
<li><a class="anchor" id="Stuben_1999"></a><em>K. Stuben,</em> Algebraic multigrid (AMG): an introduction with applications, Journal of Computational and Applied Mathematics, 2001, Vol. 128, Pp. 281-309.</li>
<li><a class="anchor" id="Vanek_1996"></a><em>P. Vanek, J. Mandel, M. Brezina,</em> Algebraic multigrid by smoothed aggregation for second and fourth order elliptic problems, Computing 56, 1996, Pp. 179-196.</li>
<li><a class="anchor" id="Notay_2008"></a><em>Y. Notay, P. Vassilevski,</em> Recursive Krylov-based multigrid cycles, Numer. Linear Algebra Appl. 2008; 15:473-487.</li>
<li><a class="anchor" id="Templates_1994"></a><em>R. Barrett, M. Berry, T. F. Chan et al.</em> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods, 2nd Edition, SIAM, Philadelphia, PA, 1994.</li>
<li><a class="anchor" id="spai_2002"></a><em>O. Broeker, M. Grote,</em> Sparse approximate inverse smoothers for geometric and algebraic multigrid, Applied Numerical Mathematics, Volume 41, Issue 1, April 2002, Pages 61–80.</li>
<li><a class="anchor" id="Sala_2008"></a><em>M. Sala, R. Tuminaro,</em> A new Petrov-Galerkin smoothed aggregation preconditioner for nonsymmetric linear systems. SIAM J. Sci. Comput. 2008, Vol. 31, No.1, pp. 143-166. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
